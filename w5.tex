\section*{Week 5 (2/3 - 2/9; Chp.3, Quiz 3)}

\problem{
    w20m2q1
}{
    What is one of the most simplest(and oldest) techniques for exploiting parallelism among instructions?
}{
    Pipelining
}

\problem{
    f12m1q13
    f13m1q12
    w13f0p1
    f15m1q12
    w19m1q14
    w19f0q8
    w20q3q1
    w20m2q4
}{
    What are the 3 pipeline hazards? 

    Which one can be solved by providing more resources?
    (What pipeline hazard can be avoided by "throwing money at the problem"?)
}{
    Structural / Data / Control hazards

    Structural hazard can be solved.
}

\problem{
    f05m1q13
    w12m1q15
    w12f0p4
    f14m1q11
    f16m1q11
    f15m1q11
    w20q3q2
    w20m2q5
}{
    What are the 4 types of data hazards? 
    Which one can be solved by using forwarding?
    Which one is not really a hazard? Why?
}{
    RAW / WAR / WAW

    RAW can be solved by forwarding.

    \todo
}

\problem{
    \xxxxxx
    w13f0p1
    w15f0p1
    w19f0q1
    w20q3q3
}{
    When dealing with control hazards, it is not enough to predict the branch direction, what else must we know?
    (Predicting the direction of a brnach is not enough, what else is necessary?)
}{
    Branch target address
}

\problem{
    \xxxxxx
    f13f0p1
    w19f0q2
    w20q3q4
}{
    Which is on average more effective, dynamic or static branch prediction?
}{
    Dynamic
}

\problem{
    f13f0q7
    f15f0p4
    w20q3q5
    w20m2q8
    \xxxxxx
}{
    (Pipeline analysis, sampled from w20q3q5) \\
    \nop
}{
    a) 48

    b) No, Memory takes 2x time than the other. 
    Split M into 2 equally stages, each taking 24 time-units.
}

\problem{
    \xxxxxx
    w19f0q39
    w20q3q7
}{
    A simple dynamic branch prediction scheme is to use a table of 2-bit predictors, accessed using bits from the PC. 
    It would seem that the bigger the table, the better the predictor would work, is that true? 
    If not, what is the limit on how many entries the table can have and still give good perforÂ­mance?
}{
    False, 4096 bits.
}

\problem{
    f13f0p14
    f15f0p11
    w19f0q57
    w20q3q8
    w20m2q10
}{
    (Pipeline interrupt, sampled from w20q3q8) \\
    \nop
}{
    \begin{enumerate}
        \item Interrupt on \texttt{i+1} and squash the next two.
        \item Squash \texttt{i+1} to \texttt{i+5}
        \item 5, WB stage cannot go wrong.
    \end{enumerate}
}

\problem{
    f13f0p4
    f14m2p1
    f16f0p4
}{
    Why do most pipelined machines avoid the use of condition codes?
}{
    It decreases the times you need to do the branch prediction.
}
